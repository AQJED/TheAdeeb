<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architectural Filtering: Moving from User-Space to the Kernel</title>
    <style>
        /* --- SAME CSS AS HOMEPAGE FOR CONSISTENCY --- */
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-main: #e2e8f0;
            --text-muted: #94a3b8;
            --accent: #10b981;
            --accent-hover: #34d399;
            --font-mono: 'Courier New', Courier, monospace;
            --font-sans: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-sans);
            line-height: 1.8;
        }

        a { text-decoration: none; color: inherit; transition: 0.2s; }

        .container { max-width: 800px; margin: 0 auto; padding: 0 20px; }

        header { padding: 20px 0; border-bottom: 1px solid #334155; margin-bottom: 60px; }
        nav { display: flex; justify-content: space-between; align-items: center; }
        .logo { font-family: var(--font-mono); font-weight: bold; font-size: 1.2rem; color: var(--accent); }
        .back-link { font-size: 0.9rem; color: var(--text-muted); }
        .back-link:hover { color: var(--accent); }

        article h1 { font-size: 2.5rem; margin-bottom: 10px; line-height: 1.2; }
        .meta { color: var(--text-muted); font-family: var(--font-mono); font-size: 0.85rem; margin-bottom: 40px; display: block; }
        
        article h3 { 
            color: var(--accent); 
            font-family: var(--font-mono); 
            margin-top: 40px; 
            margin-bottom: 15px; 
            font-size: 1.4rem; 
        }

        article p { margin-bottom: 20px; font-size: 1.1rem; color: #cbd5e1; }
        strong { color: white; }

        .callout {
            background-color: #162032;
            border-left: 4px solid var(--accent);
            padding: 20px;
            margin: 30px 0;
            font-style: italic;
            color: var(--text-muted);
        }

        footer {
            text-align: center;
            padding: 60px 0;
            color: var(--text-muted);
            font-size: 0.9rem;
            border-top: 1px solid #334155;
            margin-top: 80px;
        }
    </style>
</head>
<body>

    <header>
        <div class="container">
            <nav>
                <div class="logo">&lt;Solo_Dev /&gt;</div>
                <a href="index.html" class="back-link">← Back to Logs</a>
            </nav>
        </div>
    </header>

    <div class="container">
        <article>
            <span class="meta">TAGS: NETWORKING // PERFORMANCE // BPF</span>
            <h1>Architectural Filtering: Moving from User-Space to the Kernel</h1>
            
            <h3>The Initial Assumption</h3>
            <p>
                I was tasked with integrating Computer Generated Forces (CGF) with a middleware component. The objective was to receive Distributed Interactive Simulation (DIS) packets over the network and write them into a Shared Memory block for real-time processing. 
            </p>
            <p>
                My initial assumption was that since this specific Ethernet port was dedicated to simulation traffic, I could treat the incoming stream as clean data.
            </p>

            <h3>The Failure Point</h3>
            <p>
                The application suffered frequent segmentation faults. The issue was not in the processing logic, but in the OpenDIS parser itself. 
            </p>
            <div class="callout">
                "By listening to the raw interface (ETH0), the application was capturing all network traffic, not just simulation data."
            </div>
            <p>
                The parser was receiving ARP requests, background OS broadcasts, and unrelated network chatter. When the parser attempted to deserialize a standard Windows networking packet as a simulation PDU, the bitstream did not align with the expected protocol structure, causing the application to fail.
            </p>

            <h3>Attempt 1: Manual Header Validation</h3>
            <p>
                My first instinct was to validate the packets in the application code. I implemented a check to verify the DIS Protocol ID in the first few bytes before passing the data to the library.
            </p>
            <p>
                While this stopped the crashes, it introduced significant latency. The application was now double-handling every byte—once for manual validation and again inside the library's internal logic. In a real-time environment where millisecond precision is required, this overhead was unacceptable.
            </p>

            <h3>Attempt 2: User-Space Filtering</h3>
            <p>
                I then attempted to filter by IP and Port within the application’s socket loop. This was still inefficient. The Network Interface Card (NIC) was still triggering interrupts for every packet, and the Kernel was still copying that data into User Space just for my application to discard it. I was wasting CPU cycles on context switching for data that should have never been processed.
            </p>

            <h3>The Solution: Berkeley Packet Filter (BPF)</h3>
            <p>
                The correct architectural approach was to move the filtering logic into the Kernel using BPF. BPF allows you to define a bytecode filter that the Kernel executes the moment a packet hits the network stack.
            </p>
            <p>
                By attaching a BPF filter to the socket, the Kernel evaluates the packet immediately. If the packet is not a valid DIS PDU, it is dropped at the stack level. My application is never notified, no memory is copied to User Space, and the Shared Memory remains clean.
            </p>

            <h3>The Takeaway</h3>
            <p>
                In high-performance simulation, you cannot assume the network wire is clean. Architectural decisions regarding where data is filtered have direct consequences on system stability and latency.
            </p>
            <ul>
                <li><strong>Filter at the Entry Point:</strong> Waiting until data reaches the application to filter it results in lost performance.</li>
                <li><strong>Protect the Parser:</strong> Parsers are often fragile and should only see data that conforms to the expected protocol.</li>
                <li><strong>Understand the Kernel/User Boundary:</strong> Moving logic to the Kernel is an effective way to reduce CPU load and context switching in networking applications.</li>
            </ul>
        </article>
    </div>

    <footer>
        <div class="container">
            <p>Built by Adeeb. Code. Crash. Learn. Repeat.</p>
        </div>
    </footer>

</body>
</html>
